package com.zwyue.behavior.strategy;

/**
 * 行为型设计模式，策略模式
 * 最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断
 *
 * 策略模式，英文全称是是 Strategy Design Pattern
 *
 * 在 GoF 的《设计模式》一书中，它是这么定义的：
 *  Define a family of algorithms, encapsulate each one, and make them interchangeable.
 *  Strategy lets the algorithm vary independently from clients that use it.
 *
 *  定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。
 *  策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）
 *
 * 工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。
 * 策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。
 *
 * 策略模式适用于根据不同类型的动态，决定使用哪种策略这样一种应用场景。
 *
 * 1. 策略的定义
 * 策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。
 * 因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。
 *
 * 2. 策略的创建
 * 因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。
 * 为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。
 *
 * 一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用 getStrategy() 的时候，都创建一个新的策略对象。
 * 针对这种情况，我们可以使用工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。
 * 相反，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象.
 *
 * 3. 策略的使用
 * 策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。
 * 这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。
 */